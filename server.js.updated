const express = require('express');
const morgan = require('morgan');
const helmet = require('helmet');
const cors = require('cors');
const dotenv = require('dotenv');
const mongoose = require('mongoose');
const ethers = require('ethers');

// Load environment variables
dotenv.config();

// Import User model
const User = require('./user');

// Create Express app
const app = express();
app.set('trust proxy', 1);

// Connect to MongoDB
const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGO_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    console.log(`MongoDB Connected: ${conn.connection.host}`);
  } catch (error) {
    console.error(`Error: ${error.message}`);
    process.exit(1);
  }
};

connectDB();

// Middleware
app.use(helmet());
app.use(express.json({ limit: '1mb' }));
app.use(morgan('dev'));
app.use(cors());

// Routes
const sessionRoutes = express.Router();

// Register a new session
sessionRoutes.post('/register', async (req, res) => {
  try {
    const { userAddress, publicKey, signature, validUntil } = req.body;
    
    // Validate required fields
    if (!userAddress || !publicKey || !signature || !validUntil) {
      return res.status(400).json({
        status: 'error',
        message: 'Missing required fields'
      });
    }
    
    // Verify the signature
    const message = `I authorize this session key for Monad Runner:
Public Key: ${publicKey.substring(0, 20)}...
Valid Until: ${new Date(validUntil * 1000).toISOString()}
Address: ${userAddress}`;
    
    try {
      const recoveredAddress = ethers.verifyMessage(message, signature);
      if (recoveredAddress.toLowerCase() !== userAddress.toLowerCase()) {
        return res.status(401).json({
          status: 'error',
          message: 'Invalid signature'
        });
      }
    } catch (error) {
      console.error("Signature verification error:", error);
      return res.status(401).json({
        status: 'error',
        message: 'Failed to verify signature'
      });
    }
    
    // Find or create user
    let user = await User.findOne({ walletAddress: userAddress.toLowerCase() });
    if (!user) {
      user = new User({ walletAddress: userAddress.toLowerCase() });
    }
    
    // Clean expired sessions
    user.cleanExpiredSessions();
    
    // Add new session key
    user.sessionKeys.push({
      publicKey,
      signature,
      validUntil: new Date(validUntil * 1000),
      isRevoked: false,
      createdAt: new Date()
    });
    
    await user.save();
    
    return res.status(200).json({
      status: 'success',
      message: 'Session registered successfully',
      validUntil
    });
  } catch (error) {
    console.error("Session registration error:", error);
    return res.status(500).json({
      status: 'error',
      message: 'Internal server error'
    });
  }
});

// Check session status
sessionRoutes.post('/status', async (req, res) => {
  try {
    const { userAddress } = req.body;
    
    // Validate required fields
    if (!userAddress) {
      return res.status(400).json({
        status: 'error',
        message: 'Missing required fields'
      });
    }
    
    // Find user
    const user = await User.findOne({ walletAddress: userAddress.toLowerCase() });
    if (!user) {
      return res.status(200).json({
        status: 'success',
        hasSession: false
      });
    }
    
    // Check for valid session keys
    user.cleanExpiredSessions(); // Clean expired sessions first
    
    // Find the most recent valid session
    const validSession = user.sessionKeys.find(key => !key.isRevoked);
    
    if (!validSession) {
      return res.status(200).json({
        status: 'success',
        hasSession: false
      });
    }
    
    // Return session status with minimal session data (careful not to expose private key)
    return res.status(200).json({
      status: 'success',
      hasSession: true,
      sessionData: {
        publicKey: validSession.publicKey,
        validUntil: validSession.validUntil,
        signature: validSession.signature,
        createdAt: validSession.createdAt
      }
    });
  } catch (error) {
    console.error("Session status check error:", error);
    return res.status(500).json({
      status: 'error',
      message: 'Internal server error'
    });
  }
});

// Revoke a session
sessionRoutes.post('/revoke', async (req, res) => {
  try {
    const { userAddress, publicKey } = req.body;
    
    // Validate required fields
    if (!userAddress || !publicKey) {
      return res.status(400).json({
        status: 'error',
        message: 'Missing required fields'
      });
    }
    
    // Find user
    const user = await User.findOne({ walletAddress: userAddress.toLowerCase() });
    if (!user) {
      return res.status(404).json({
        status: 'error',
        message: 'User not found'
      });
    }
    
    // Revoke session
    const revoked = user.revokeSession(publicKey);
    if (!revoked) {
      return res.status(404).json({
        status: 'error',
        message: 'Session key not found'
      });
    }
    
    await user.save();
    
    return res.status(200).json({
      status: 'success',
      message: 'Session revoked successfully'
    });
  } catch (error) {
    console.error("Session revocation error:", error);
    return res.status(500).json({
      status: 'error',
      message: 'Internal server error'
    });
  }
});

// Import the executeContractTransaction function
// Note: In your actual backend, you would use a require statement
// const { executeContractTransaction } = require('./contractUtils');

// Environment variables needed:
// - MONAD_RPC_URL: Monad blockchain node URL (e.g., https://rpc.monad.xyz/testnet)
// - SERVER_WALLET_KEY: Private key of server wallet (keep this secure!)
// 
// Make sure the server wallet has enough MONAD tokens to pay for gas fees
// This wallet will submit transactions on behalf of users with session keys

// Transaction with session key
sessionRoutes.post('/transaction', async (req, res) => {
  try {
    const {
      userAddress,
      publicKey,
      signature,
      contractAddress,
      functionName,
      args
    } = req.body;
    
    console.log('Transaction request received:', {
      userAddress,
      publicKey,
      contractAddress,
      functionName,
      args: JSON.stringify(args)
    });
    
    // Validate required fields
    if (!userAddress || !publicKey || !signature || !contractAddress || !functionName) {
      return res.status(400).json({
        status: 'error',
        message: 'Missing required fields'
      });
    }
    
    // Find user
    const user = await User.findOne({ walletAddress: userAddress.toLowerCase() });
    if (!user) {
      return res.status(404).json({
        status: 'error',
        message: 'User not found'
      });
    }
    
    // Check if session is valid
    const isValid = user.isSessionValid(publicKey);
    if (!isValid) {
      return res.status(401).json({
        status: 'error',
        message: 'Invalid or expired session'
      });
    }
    
    // Convert string values back to BigInt where needed for contract interactions
    // This is handled by ethers.js when it processes the transaction
    
    // TODO: Implement actual transaction processing with a relayer
    
    // For demonstration, log the args received
    console.log("Function:", functionName);
    console.log("Args:", args);
    
    // Log what we're about to do
    console.log("CONTRACT INTERACTION:", {
      contractAddress, 
      functionName, 
      args
    });
    
    // IMPLEMENTATION OPTIONS:
    
    // OPTION 1: Mock Implementation (current state)
    // This just returns a fake transaction hash and doesn't interact with the blockchain
    const mockTxHash = `0x${Math.random().toString(16).substring(2)}${Math.random().toString(16).substring(2)}`;
    
    // OPTION 2: Real Implementation (uncomment and configure to use)
    // Make sure you have proper environment variables set up:
    // - SERVER_WALLET_KEY: The private key of your server's wallet (keep secure!)
    // - MONAD_RPC_URL: The URL of your Monad node
    /*
    try {
      // Verify the user has a valid session
      const user = await User.findOne({ walletAddress: userAddress.toLowerCase() });
      if (!user) {
        return res.status(404).json({
          status: 'error',
          message: 'User not found'
        });
      }
      
      // Find the matching session key
      const session = user.sessionKeys.find(key => 
        key.publicKey === publicKey && 
        !key.isRevoked &&
        new Date(key.validUntil) > new Date()
      );
      
      if (!session) {
        return res.status(401).json({
          status: 'error',
          message: 'Invalid or expired session'
        });
      }
      
      // Verify the signature (optional additional security)
      // ... signature verification logic here ...
      
      // Execute the transaction
      console.log(`Submitting transaction to Monad for user ${userAddress}`);
      const result = await executeContractTransaction(
        contractAddress,
        functionName,
        args,
        process.env.SERVER_WALLET_KEY,
        process.env.MONAD_RPC_URL
      );
      
      console.log(`Transaction successful: ${result.txHash}`);
      
      // Record the transaction in your database (optional)
      // ... transaction recording logic here ...
      
      return res.status(200).json({
        status: 'success',
        txHash: result.txHash
      });
    } catch (error) {
      console.error("Blockchain transaction error:", error);
      return res.status(500).json({
        status: 'error',
        message: error.message || "Blockchain transaction failed"
      });
    }
    */
    
    // Until you implement OPTION 2, this mock response is returned
    return res.status(200).json({
      status: 'success',
      txHash: mockTxHash,
      warning: "This is a mock transaction. Configure your server to execute real blockchain transactions!"
    });
  } catch (error) {
    console.error("Transaction processing error:", error);
    return res.status(500).json({
      status: 'error',
      message: error.message || 'Internal server error'
    });
  }
});

// Mount session routes
app.use('/runnerapi/session', sessionRoutes);

// Health check endpoint
app.get('/health', (req, res) => {
  res.status(200).json({
    status: 'success',
    message: 'Monad Runner Session API is running'
  });
});

// Handle 404s
app.all('*', (req, res) => {
  res.status(404).json({
    status: 'error',
    message: `Route ${req.originalUrl} not found`
  });
});

// Start server
const PORT = process.env.PORT || 5001;
const server = app.listen(PORT, () => {
  console.log(`Session server running on port ${PORT}`);
});

// Handle unhandled rejections
process.on('unhandledRejection', (err) => {
  console.error('UNHANDLED REJECTION! Shutting down...');
  console.error(err.name, err.message);
  server.close(() => {
    process.exit(1);
  });
});

module.exports = app;