const ethers = require('ethers');

// For Monad Runner ABI - this is a partial ABI focusing just on the functions we need
const MONAD_RUNNER_ABI = [
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "score",
        "type": "uint256"
      },
      {
        "internalType": "bytes32",
        "name": "replayHash",
        "type": "bytes32"
      }
    ],
    "name": "submitScore",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "username",
        "type": "string"
      }
    ],
    "name": "registerPlayer",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "username",
        "type": "string"
      }
    ],
    "name": "updateUsername",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }
];

// Function to execute contract transactions from the server on behalf of the player
async function executeContractTransaction(contractAddress, functionName, args, serverPrivateKey, rpcUrl) {
  try {
    // Set up provider and signer
    const provider = new ethers.providers.JsonRpcProvider(rpcUrl);
    const wallet = new ethers.Wallet(serverPrivateKey, provider);
    
    // Use the predefined ABI
    
    // Create contract instance
    const contract = new ethers.Contract(contractAddress, MONAD_RUNNER_ABI, wallet);
    
    // Handle special cases for function arguments based on the function name
    let parsedArgs;
    
    if (functionName === 'submitScore') {
      // For submitScore, the first arg is a score (should be a number) and second is a replayHash
      if (args.length !== 2) {
        throw new Error(`submitScore requires exactly 2 arguments, got ${args.length}`);
      }
      
      // Score should be a number or numeric string, convert to BigNumber
      const score = typeof args[0] === 'string' ? ethers.BigNumber.from(args[0]) : args[0];
      
      // ReplayHash should be a 32-byte hash, and should already be in hex format
      // If it doesn't start with 0x, add it
      let replayHash = args[1];
      if (!replayHash.startsWith('0x')) {
        replayHash = '0x' + replayHash;
      }
      
      parsedArgs = [score, replayHash];
    } else if (functionName === 'registerPlayer' || functionName === 'updateUsername') {
      // For username-related functions, just pass the string through
      parsedArgs = args;
    } else {
      // For other functions, convert number strings to BigNumber
      parsedArgs = args.map(arg => {
        if (typeof arg === 'string' && /^\d+$/.test(arg)) {
          return ethers.BigNumber.from(arg);
        }
        return arg;
      });
    }
    
    console.log(`Executing ${functionName} with args:`, parsedArgs);
    
    // Call the function with the parsed args
    const tx = await contract[functionName](...parsedArgs);
    
    // Wait for the transaction to be mined
    const receipt = await tx.wait();
    
    console.log(`Transaction successful! Hash: ${receipt.transactionHash}`);
    
    return {
      success: true,
      txHash: receipt.transactionHash
    };
  } catch (error) {
    console.error("Error executing contract transaction:", error);
    throw error;
  }
}

module.exports = {
  executeContractTransaction
};