{
  "language": "Solidity",
  "sources": {
    "contracts/MonadRunnerGame.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title MonadRunnerGame\n * @dev Smart contract for storing Monad Runner game data on-chain,\n *      including registration of a smart account for account abstraction.\n *      Optimized for minimal gas usage.\n */\ncontract MonadRunnerGame {\n    // =============== EVENTS ===============\n    event PlayerRegistered(address indexed playerAddress, string username);\n    event UsernameChanged(address indexed playerAddress, string newUsername);\n    event ScoreSubmitted(address indexed playerAddress, uint256 score, uint256 timestamp, bytes32 replayHash);\n    event ReplayDataStored(address indexed playerAddress, bytes32 indexed replayHash);\n    event SmartAccountRegistered(address indexed eoa, address smartAccount);\n    event RelayerAdded(address indexed relayer);\n    event RelayerRemoved(address indexed relayer);\n\n    // =============== STRUCTS ===============\n    struct Player {\n        string username;\n        uint256 highScore;\n        uint256 timesPlayed;\n        uint256 lastPlayed;\n        bool exists;\n    }\n\n    struct GameScore {\n        address playerAddress;\n        uint256 score;\n        uint256 timestamp;\n        bytes32 replayHash;\n    }\n\n    // =============== CONSTANTS ===============\n    // Using constant for fixed values saves gas\n    uint256 private constant MAX_LEADERBOARD_SIZE = 100;\n    uint256 private constant MAX_USERNAME_LENGTH = 20;\n    uint256 private constant MAX_PLAYER_SCORE_HISTORY = 10;\n    \n    // Cheaper to use uint8 for small numbers (uses less storage)\n    uint8 private constant USERNAME_PREFIX_LENGTH = 7; // \"Player_\"\n\n    // =============== STATE VARIABLES ===============\n    // Immutable variables cost less gas than regular state variables\n    address public immutable owner;\n    \n    // Pack related data together when possible\n    mapping(address => Player) public players;\n    mapping(address => address) public smartAccounts;\n    mapping(bytes32 => bool) public replayExists;\n    mapping(address => bool) public authorizedRelayers;\n    \n    // Separate mappings for arrays to avoid storage bloat\n    mapping(address => GameScore[]) private playerScoreHistory;\n    address[] public playerAddresses;\n    GameScore[] public topScores;\n\n    // =============== CONSTRUCTOR ===============\n    constructor() {\n        owner = msg.sender;\n        // Add the deployer as the first authorized relayer\n        authorizedRelayers[msg.sender] = true;\n        emit RelayerAdded(msg.sender);\n    }\n\n    // =============== MODIFIERS ===============\n    // Use custom errors instead of revert strings to save gas\n    error OnlyOwner();\n    error OnlyRegisteredPlayer();\n    error OnlyAuthorizedRelayer();\n    error PlayerAlreadyRegistered();\n    error PlayerDoesNotExist();\n    error InvalidSmartAccount();\n    error UsernameTooLong();\n    error UsernameEmpty();\n    error ReplayAlreadyExists();\n    error InvalidRelayerAddress();\n    error NotAnAuthorizedRelayer();\n\n    modifier onlyOwner() {\n        if (msg.sender != owner) revert OnlyOwner();\n        _;\n    }\n\n    modifier onlyRegisteredPlayer() {\n        if (!players[msg.sender].exists) revert OnlyRegisteredPlayer();\n        _;\n    }\n\n    modifier onlyAuthorizedRelayer() {\n        if (!authorizedRelayers[msg.sender]) revert OnlyAuthorizedRelayer();\n        _;\n    }\n\n    // =============== ADMIN FUNCTIONS ===============\n    function addRelayer(address relayer) external onlyOwner {\n        if (relayer == address(0)) revert InvalidRelayerAddress();\n        authorizedRelayers[relayer] = true;\n        emit RelayerAdded(relayer);\n    }\n\n    function removeRelayer(address relayer) external onlyOwner {\n        if (!authorizedRelayers[relayer]) revert NotAnAuthorizedRelayer();\n        authorizedRelayers[relayer] = false;\n        emit RelayerRemoved(relayer);\n    }\n\n    // =============== EXTERNAL FUNCTIONS ===============\n    function registerPlayer(string calldata username) external {\n        // Using calldata for string parameters saves gas when the function doesn't modify the string\n        if (players[msg.sender].exists) revert PlayerAlreadyRegistered();\n        \n        uint256 len = bytes(username).length;\n        if (len == 0) revert UsernameEmpty();\n        if (len > MAX_USERNAME_LENGTH) revert UsernameTooLong();\n\n        // Initialize all fields directly to save gas\n        players[msg.sender] = Player({\n            username: username,\n            highScore: 0,\n            timesPlayed: 0,\n            lastPlayed: 0,\n            exists: true\n        });\n        \n        playerAddresses.push(msg.sender);\n        emit PlayerRegistered(msg.sender, username);\n    }\n\n    function updateUsername(string calldata newUsername) external onlyRegisteredPlayer {\n        uint256 len = bytes(newUsername).length;\n        if (len == 0) revert UsernameEmpty();\n        if (len > MAX_USERNAME_LENGTH) revert UsernameTooLong();\n        \n        players[msg.sender].username = newUsername;\n        emit UsernameChanged(msg.sender, newUsername);\n    }\n\n    function registerSmartAccount(address smartAccount) external onlyRegisteredPlayer {\n        if (smartAccount == address(0)) revert InvalidSmartAccount();\n        smartAccounts[msg.sender] = smartAccount;\n        emit SmartAccountRegistered(msg.sender, smartAccount);\n    }\n\n    function registerSmartAccountFor(address playerAddress, address smartAccount) external onlyAuthorizedRelayer {\n        if (smartAccount == address(0)) revert InvalidSmartAccount();\n        \n        // Gas optimization: Store the existence check result\n        bool playerExists = players[playerAddress].exists;\n        \n        // For EIP-7702, if the player doesn't exist yet but the smart account\n        // is the same as the player address, register the player automatically\n        if (!playerExists && playerAddress == smartAccount) {\n            // Generate username only when needed (gas optimization)\n            string memory username = _generateDefaultUsername(playerAddress);\n            \n            players[playerAddress] = Player({\n                username: username,\n                highScore: 0,\n                timesPlayed: 0,\n                lastPlayed: 0,\n                exists: true\n            });\n            \n            playerAddresses.push(playerAddress);\n            emit PlayerRegistered(playerAddress, username);\n        } else {\n            // Otherwise, require that the player already exists\n            if (!playerExists) revert PlayerDoesNotExist();\n        }\n        \n        smartAccounts[playerAddress] = smartAccount;\n        emit SmartAccountRegistered(playerAddress, smartAccount);\n    }\n\n    function submitScore(uint256 score, bytes32 replayHash) external onlyRegisteredPlayer {\n        // Gas optimization: Use storage pointer\n        Player storage player = players[msg.sender];\n        \n        // Unchecked math for gas optimization when overflow is impossible\n        unchecked {\n            player.timesPlayed++;\n        }\n        \n        player.lastPlayed = block.timestamp;\n        \n        // Only update highScore if needed\n        if (score > player.highScore) {\n            player.highScore = score;\n        }\n        \n        GameScore memory newScore = GameScore({\n            playerAddress: msg.sender,\n            score: score,\n            timestamp: block.timestamp,\n            replayHash: replayHash\n        });\n        \n        replayExists[replayHash] = true;\n        _addToPlayerScoreHistory(msg.sender, newScore);\n        _updateLeaderboard(newScore);\n        \n        emit ScoreSubmitted(msg.sender, score, block.timestamp, replayHash);\n        emit ReplayDataStored(msg.sender, replayHash);\n    }\n\n    function storeReplayDataHash(bytes32 replayHash) external onlyRegisteredPlayer {\n        if (replayExists[replayHash]) revert ReplayAlreadyExists();\n        replayExists[replayHash] = true;\n        emit ReplayDataStored(msg.sender, replayHash);\n    }\n\n    // =============== VIEW FUNCTIONS ===============\n    function getPlayer(address playerAddress) external view returns (Player memory) {\n        if (!players[playerAddress].exists) revert PlayerDoesNotExist();\n        return players[playerAddress];\n    }\n\n    function getTopScores(uint256 count) external view returns (GameScore[] memory) {\n        // Gas optimization: Avoid unnecessary copies\n        uint256 actualCount = topScores.length;\n        if (count > actualCount) {\n            count = actualCount;\n        }\n        \n        GameScore[] memory results = new GameScore[](count);\n        \n        // Use unchecked when overflow is impossible (gas optimization)\n        unchecked {\n            for (uint256 i = 0; i < count; i++) {\n                results[i] = topScores[i];\n            }\n        }\n        \n        return results;\n    }\n\n    function getPlayerScoreHistory(address playerAddress) external view returns (GameScore[] memory) {\n        if (!players[playerAddress].exists) revert PlayerDoesNotExist();\n        return playerScoreHistory[playerAddress];\n    }\n\n    function getPlayerRank(address playerAddress) external view returns (uint256) {\n        if (!players[playerAddress].exists) revert PlayerDoesNotExist();\n        \n        uint256 length = topScores.length;\n        // Use unchecked when overflow is impossible (gas optimization)\n        unchecked {\n            for (uint256 i = 0; i < length; i++) {\n                if (topScores[i].playerAddress == playerAddress) {\n                    return i + 1;\n                }\n            }\n        }\n        \n        return 0;\n    }\n\n    function getPlayerCount() external view returns (uint256) {\n        return playerAddresses.length;\n    }\n\n    function isAuthorizedRelayer(address relayer) external view returns (bool) {\n        return authorizedRelayers[relayer];\n    }\n\n    // =============== INTERNAL FUNCTIONS ===============\n    function _addToPlayerScoreHistory(address playerAddress, GameScore memory score) internal {\n        GameScore[] storage history = playerScoreHistory[playerAddress];\n        uint256 length = history.length;\n        \n        if (length >= MAX_PLAYER_SCORE_HISTORY) {\n            // Shift items to make room (gas optimization using unchecked)\n            unchecked {\n                for (uint256 i = 0; i < length - 1; i++) {\n                    history[i] = history[i + 1];\n                }\n            }\n            history.pop();\n        }\n        \n        history.push(score);\n    }\n\n    function _updateLeaderboard(GameScore memory newScore) internal {\n        uint256 length = topScores.length;\n        \n        if (length < MAX_LEADERBOARD_SIZE) {\n            uint256 pos = _findInsertionPosition(newScore.score);\n            \n            topScores.push(GameScore({\n                playerAddress: address(0),\n                score: 0,\n                timestamp: 0,\n                replayHash: bytes32(0)\n            }));\n            \n            // Shift items to make room\n            unchecked {\n                for (uint256 i = length; i > pos; i--) {\n                    topScores[i] = topScores[i - 1];\n                }\n            }\n            \n            topScores[pos] = newScore;\n        } else if (newScore.score > topScores[length - 1].score) {\n            uint256 pos = _findInsertionPosition(newScore.score);\n            \n            // Shift items to make room\n            unchecked {\n                for (uint256 i = length - 1; i > pos; i--) {\n                    topScores[i] = topScores[i - 1];\n                }\n            }\n            \n            topScores[pos] = newScore;\n        }\n    }\n\n    function _findInsertionPosition(uint256 score) internal view returns (uint256) {\n        uint256 left = 0;\n        uint256 right = topScores.length;\n        \n        while (left < right) {\n            uint256 mid = (left + right) / 2;\n            if (topScores[mid].score > score) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        \n        return left;\n    }\n\n    // Optimized username generation for lower gas\n    function _generateDefaultUsername(address playerAddress) internal pure returns (string memory) {\n        // Fixed prefix \"Player_\" + last 8 hex chars of address\n        bytes memory result = new bytes(15); // 7 for \"Player_\" + 8 for hex\n        \n        // Copy \"Player_\" prefix\n        result[0] = \"P\";\n        result[1] = \"l\";\n        result[2] = \"a\";\n        result[3] = \"y\";\n        result[4] = \"e\";\n        result[5] = \"r\";\n        result[6] = \"_\";\n        \n        // Extract last 4 bytes of address (8 hex chars)\n        bytes20 addrBytes = bytes20(playerAddress);\n        \n        // Optimize for gas by using bitwise operations and direct assignment\n        unchecked {\n            for (uint256 i = 0; i < 4; i++) {\n                uint8 b = uint8(addrBytes[16 + i]); // last 4 bytes\n                result[7 + i*2] = _getHexChar(b >> 4); // high nibble\n                result[8 + i*2] = _getHexChar(b & 0x0f); // low nibble\n            }\n        }\n        \n        return string(result);\n    }\n    \n    // Gas-optimized hex conversion\n    function _getHexChar(uint8 value) internal pure returns (bytes1) {\n        // Using inline assembly for the most gas-efficient conversion\n        bytes1 c;\n        assembly {\n            // Add '0' (48) for 0-9, or 'a'-10 (97-10=87) for a-f\n            c := add(add(value, mul(lt(value, 10), 48)), mul(iszero(lt(value, 10)), 87))\n        }\n        return c;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}